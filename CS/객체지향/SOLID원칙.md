# SOLID 원칙

> **SOLID 원칙** : 객체지향 프로그래밍을 하면서 5가지 핵심 원칙을 지킨다면, 변경이 용이하고, 유지보수와 확장성이 좋은 소프트웨어를 개발하는데 도움이 되는 것

## 목차

- [단일 책임 원칙(SRP, Single Responsibility Principle)](#단일-책임-원칙(SRP,-Single-Responsibility-Principle))
- [개방 폐쇄 원칙(OCP, Open Closed  Principle)](#개방-폐쇄-원칙(OCP,-Open-Closed-Principle))
- [리스코프 치환 원칙(LSP, Liskov Substitution Principle)](#리스코프-치환-원칙(LSP,-Liskov-Substitution-Principle))
- [인터페이스 분리 원칙(ISP, Interface Segregation Principle)](#인터페이스-분리-원칙(ISP,-Interface-Segregation-Principle))
- [의존 역전 원칙(DIP, Dependency Inversion Principle)](#의존-역전-원칙(DIP,-Dependency-Inversion-Principle))

---

## 단일 책임 원칙(SRP, Single Responsibility Principle)

> 클래스(객체)는 하나의 책임만 가져야한다는 원칙

여기서 **책임**은 **기능**이라는 뜻으로 받아들여 **하나의 기능**만 가져야한다고 생각하면 된다. </br>

즉, 클래스 하나에 여러 개의 기능을 구현해놓는 것이 아닌, 클래스 하나엔 하나의 기능만 구현하도록 설계해 변경에 용이하게 만들으라는 의미다.

`청소 기능만을 수행하는 청소기 클래스`가 있다고 해보자.
이때는 **단일 책임 원칙**에 맞게 설계했다고 할 수 있다.
하지만 만약, 청소기 클래스가 `문자 기능과 전화 기능`까지 있다고 가정해보자.
기능이 많으면 좋다고 생각할 수 있겠지만, 청소기 클래스에 **오류가 발생**하면 청소기능뿐만 아니라 문자 기능과 전화기능까지 사용하지 못하게된다.

따라서 **클래스 하나에 하나의 기능**만 구현하는 것이 좋다.

---

## 개방 폐쇄 원칙(OCP, Open Closed  Principle)

> 클래스는 확장에는 열려있어야 하며, 수정에는 닫혀있어야 한다는 원칙

- `확장에 열려있다` : 새로운 기능 요청이 들어왔을 때 유연하게 코드를 추가하거나 변경해 쉽게 확장할 수 있다.
- `수정에 닫혀있다` : 새로운 기능 요청이 들어왔을 때 기존 코드를 변경하지 않고 애플리케이션의 동작을 추가하거나 변경할 수 있다.

즉, **개방 폐쇄 원칙**은 추상화를 통한 관계 구축하는 것을 권장하는 원칙이라고 볼 수 있다.
Java에서는 추상 클래스나 상속을 통한 클래스 관계 구축을 의미한다.

---

## 리스코프 치환 원칙(LSP, Liskov Substitution Principle)

> 하위 타입은 상위 타입을 대체할 수 있어야 한다는 원칙

자식 객체의 타입이 부모 객체의 타입으로 변경 즉, `업캐스팅`되어도 올바르게 동작해야한다는 것이다.

리스코프 치환 원칙은 객체지향의 특징 중 하나인 다형성을 이용하기 위한 원칙이라고 볼 수 있다.

- `다형성` : 같은 이름의 메소드나 연산자가 다른 클래스에 대해 다른 동작을 하도록 하는 것

---

## 인터페이스 분리 원칙(ISP, Interface Segregation Principle)

> 인터페이스를 각각 사용에 맞게끔 세분화해 분리해야 한다는 원칙

`SRP`가 **클래스(객체)의 단일 책임**을 강조했다면, ISP는 **인터페이스의 단일 책임**를 강조하는 것으로 보면 된다.

어떤 인터페이스에 새로운 기능이 필요하다면 이 인터페이스의 기능을 구현하는 다른 인터페이스를 만들어 새로운 기능을 추가해 해결할 수 있다.

예를 들어, **파일 읽기/쓰기 기능**을 갖는 인터페이스가 있는데 어떤 클라이언트는 **읽기 기능**만을 필요로 한다면 **읽기 기능만을 갖는 새로운 인터페이스**를 만들어 제공해주는 것이다.

---

## 의존 역전 원칙(DIP, Dependency Inversion Principle)

> 어떤 클래스를 참조해서 사용해야한다면, 그 클래스를 직접 참조하는 것이 아니라 그 대상의 상위 요소인 추상클래스나 인터페이스를 참조하라는 원칙 

즉, **구현 클래스**에 의존하지 말고 **인터페이스나 추상클래스**에 의존하라는 뜻으로,
의존 관계를 맺을 때 변경 가능성이 높은 **구현 클래스**보다는 변경 가능성이 낮은 **인터페이스**나 **추상클래스**에 의존하라는 의미이다.

