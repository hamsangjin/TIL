# Java 면접 질문 목록

## 1. Java의 장단점에 대해 설명해주세요.
- 장점: 객체지향 언어이면서, 플랫폼에 독립적이다.
- 단점: 수행속도가 느리며, 코드가 길어지고 복잡하다.

<br>

## 2. JVM이 무엇인지 설명해주세요.
자바 가상 머신(Java Virtual Machine)을 의미하며, 자바 바이트코드(.class 파일)를 OS에 특화된 코드로 변환하여 실행한다.

<br>

## 3. Java Application이 JVM에서 실행되는 과정을 설명해주세요.
![image](https://github.com/hamsangjin/TIL/assets/103736614/8c493c7c-0b50-4dda-8928-3165fb01334b)

Java 언어로 프로그래밍된 파일을 Java 컴파일러가 가상 기계어 파일인 Java 클래스 파일로 만들고, Java 클래스 파일의 바이트 코드를 JVM이 읽고 실행하게 된다.

<br>

## 4. JVM의 메모리(Runtime Data Area)구조에 대해 설명해주세요.
![image](https://github.com/hamsangjin/TIL/assets/103736614/e076401d-93f5-4d87-b426-9871e2fc812f)

- `Class Loader`: 클래스 파일을 Runtime Data Area의 메서드 영역으로 불러오는 역할
- `Runtime data areas`: 런타임 시 클래스 데이터와 같은 메타 데이터와 실제 데이터가 저장되는 곳
- `Execution Engine`: .class파일과 같은 ByteCode를 실행 가능하도록 해석한다.
- `Garbage Collector`: 메모리 관리 기법 중 하나로, Heap 영역에 배치된 객체들을 관리하는 모듈

<br>

## 5. Garbage Collector가 무엇인지, 어떻게 동작하는지 설명해주세요.
`Garbage Collector`는 주기적으로 JVM의 heap 메모리를 점검하여 스택에서 참조되지 않는 객체를 메모리에서 해제하는 모듈이다.

![image](https://github.com/hamsangjin/TIL/assets/103736614/0a867711-be38-4230-96ba-a43d0a4bb645)

1. Garbage collector가 Stack의 모든 변수를 스캔하면서 각각 어떤 객체를 참조하고 있는지 찾아서 마킹
2. Reachable Objec(리스트 안에 객체, 스택 → 힙(리스트) →힙(객체))가 참조하고 있는 객체도 찾아서 마킹
    - 1, 2 번을 `Mark`라 부름
3. 마킹되지 않은 객체를 Heap에서 제거 -> `Sweep`
4. compact를 하는 GC라면, 단편화된 메모리를 정리

<br>

## 6. Java에서, ==와 equals의 차이는 무엇인지 알고 있나요? 설명해주세요.
- `==`: 두 문자열의 주소(참조)값이 같은지 비교
- `equals`: 두 문자열의 내용을 비교
즉, 비교하는 대상이 주소냐, 내용이냐에 대한 차이다.

<br>

## 7. Java의 접근 제한자에 대해 설명해주세요.
`접근 제한자`란 클래스 및 인터페이스 그리고 이들이 가지고 있는 멤버의 접근을 제한하는 것을 말한다.
- `public`: 모든 접근을 허용
- `protected`: 같은 패키지(폴더)에 있는 객체와 상속관계의 객체들만 허용
- `default`: 같은 패키지(폴더)에 있는 객체들만 허용
- `private`: 현재 객체 내에서만 허용

<br>

## 8. Java에서의 데이터 타입은 무엇이 있나요?
- `기본형 타입(Primitive type)`: 논리형, 정수형, 실수형, 문자형 
- `참조형 타입(Reference type)`: 기본형 타입을 제외한 모든 타입

<br>

## 9. Java의 hashcode()에 대해 설명해주세요.
`hashCode()`는 객체의 `hashCode`를 리턴한다. 

`hashCode`는 일반적으로 각 객체의 주소값을 변환하여 생성한 객체의 고유한 정수값으로, 두 객체가 동일 객체인지 비교할 때 사용할 수 있다.

<br>

## 10. Java의 Wrapper Class에 대해 설명해주세요.
프로그램에 따라 기본 타입의 데이터를 객체로 취급해야 하는 경우가 있다.

이때에는 기본 타입의 데이터를 먼저 객체로 변환한 후 작업을 수행해야 하며, 이렇게 8개의 기본 타입에 해당하는 데이터를 객체로 포장해 주는 클래스를 `래퍼 클래스(Wrapper class)`라고 한다.

<br>

## 11. Boxing과, UnBoxing에 대해 설명해주세요.
- `Boxing` : 기본 타입의 데이터를 래퍼 클래스의 인스턴스로 변환
- `UnBoxing` : 래퍼 클래스의 인스턴스에 저장된 값을 기본 타입의 데이터로 변환

<br>

## 12. Java의 static 변수에 대해 설명해주세요.
Java에서 `static 변수`는 메모리에 한번 할당되어 프로그램이 종료될 때 해제되는 변수로, 메모리에 한번 할당되므로 여러 객체가 해당 메모리를 공유하게 된다.

<br>

## 13. Java의 main 메소드가 static인 이유에 대해 알고 있나요? (public static void main(String[] args))
메소드가 static 멤버라면 객체를 생성하지 않고도 클래스의 이름으로 직접 호출할 수 있다.

main 메소드는 프로그램을 실행하기 위한 진입점으로, static으로 선언함으로써 JVM이 main 메서드를 클래스 이름과 함께 호출할 수 있게 된다.

<br>

## 14. final과 finally, finalize의 차이에 대해 알고 있나요? 설명해주세요.
- `final`: 사용하는 대상에 따라 달라진다.
    - `변수 적용`: 변수를 상수로 지정
    - `변수 참조 적용`: 참조 변수가 힙 내의 다른 객체를 가리키도록 변경할 수 없다.
    - `메소드 적용`: 해당 메소드를 상속받는 하위 클래스에서 오버라이딩할 수 없다.
    - `클래스 적용`: 해당 클래스를 다른 클래스가 상속받을 수 없다.
- `finally`: `try-catch 블록` 뒤에 올 수 있는 선택적 블록으로, `try-catch문`이 끝나기 전에 항상 꼭 실행되어야하는 로직이 있는 경우 사용한다.
- `finalize()`: `Java GC`가 더 이상의 참조가 존재하지 않는 객체를 발견한 순간 호출하는 메소드로, 더이상 사용되지 않는 객체가 있을때 메모리 낭비를 막기 위해서 `GC`가 이 객체를 없애버릴때 해당 객체의 finallize 메소드를 호출해서 없앤다.

<br>

## 15. try-catch-finally의 단점과, 이로 인해 나온 구문에 대해 알고 있다면 설명해주세요.
`try-catch-finally문` 중 `try 블록`에서 `Scanner`나 `BufferReader`와 같은 리소스를 생성하고, 리소스를 닫을 땐 `finally 블록`에서 예외처리와 함께 작성해줘야했다.

이를 편리하기 하기 위해 `try-with-resources` 구문이 나왔고, `try` 옆에 괄호로 리소스를 생성해주면 따로 리소스를 닫을 필요없이 자동으로 닫아준다.

<br>

## 16. Java의 제네릭에 대해 설명해주세요.
`제네릭`이란 클래스 내부에서 사용할 데이터 타입을 외부에서 지정하는 기법을 의미하며, 객체별로 다른 타입의 자료가 저장될 수 있도록 한다.

<br>

## 17. Java의 직렬화와 역직렬화에 대해 설명해주세요.
- `직렬화(Serialization)`: 자바 시스템 내부에서 사용되는 객체 또는 데이터를 외부의 자바 시스템에서도 사용할 수 있도록 바이트(byte) 형태로 데이터 변환하는 기술
- `역직렬화(Deserialization)`: 반대로 스트림을 통해 받은 직렬화된 객체를 원래 모양으로 만드는 과정

<br>

## 18. 추상 클래스와 인터페이스에 대해 설명해주세요.
### 추상클래스
- 하나 이상의 추상 메소드를 포함할 수 있는 클래스다.
- 추상 클래스는 객체를 직접 생성할 수 없으며, 이를 상속받는 서브클래스에서 구현되어야 한다.
- 필드, 구체 메소드, 추상 메소드를 가질 수 있다.

### 인터페이스(Interface)
- 메소드 선언만 포함하며, 모든 메소드는 암묵적으로 `public`이고 `abstract`다.
- Java 8 이후부터는 디폴트 메소드와 정적 메소드를 가질 수 있다.
- 다중 상속이 가능하며, 구현 클래스는 모든 메소드를 구현해야 한다.

<br>

## 19. Error와 Exception의 차이에 대해 설명해주세요.
### Error
- 애플리케이션 코드에서 수습할 수 없는 심각한 문제를 나타낸다.
- 주로 JVM 레벨에서 발생하며, `메모리 부족(OutOfMemoryError)`이나 `스택 오버플로우(StackOverflowError)`와 같은 오류가 포함된다.
- Error는 보통 catch 블록으로 잡지 않으며, 애플리케이션이 이를 처리하려고 하지 않는다.

### Exception
- 애플리케이션 코드에서 수습할 수 있는 예외 상황을 나타낸다.
- 예외는 크게 두 가지로 나눌 수 있다.
    1. `Checked Exception`: 컴파일 타임에 체크되며, 반드시 처리해야 한다.
    2. `Unchecked Exception(Runtime Exception)`: 런타임에 발생하며, 컴파일러가 이를 강제하지 않는다.

<br>

## 20. String과 StringBuilder, StringBuffer의 차이에 대해 설명해주세요.
### String
- 불변(immutable) 객체로, 문자열을 수정할 수 없다.
- 문자열을 변경할 때마다 새로운 객체가 생성된다.
- thread-safe하지 않다.

### StringBuilder
- 가변(mutable) 객체로, 문자열을 수정할 수 있다.
- 문자열을 수정할 때 새로운 객체를 생성하지 않고, 기존 객체를 변경한다.
- thread-safe하지 않다.
- 일반적으로 성능이 더 좋다.

### StringBuffer
- StringBuilder와 유사하지만, thread-safe한 버전이다.
- 메소드가 synchronized로 동기화되어 있어 멀티스레드 환경에서 안전하게 사용할 수 있다.
- 성능은 StringBuilder보다 다소 떨어진다.

<br>

## 21. new String("")와 ""의 차이에 대해 메모리의 관점에서 설명해주세요.
### "" 리터럴
- 리터럴 방식으로 문자열을 생성하면, 문자열 리터럴 풀에 해당 문자열이 존재하는지 확인하고, 존재하면 그 참조를 반환한다.
- 만약 존재하지 않으면 새로운 문자열 객체를 풀에 추가하고, 그 참조를 반환한다.
- 예를 들어, `String str = "Hello";`는 리터럴 풀에 `"Hello"`가 이미 존재하면 그 참조를 사용하고, 그렇지 않으면 새로 추가한다.

### new String(""):
new 키워드를 사용하여 문자열을 생성하면, 항상 새로운 문자열 객체가 힙(heap) 메모리에 생성된다.
이 방식은 문자열 리터럴 풀을 사용하지 않으며, 풀에 동일한 문자열이 존재하더라도 새로운 객체를 생성한다.
예를 들어, `String str = new String("Hello");`는 힙 메모리에 새로운 객체를 생성한다.

### 메모리 관점
- `String str1 = "Hello";`: 문자열 리터럴 풀을 사용하여 메모리 사용을 최적화한다.
- `String str2 = new String("Hello");`: 힙 메모리에 새로운 객체를 생성하여 메모리 사용이 비효율적일 수 있다.

<br>

## 22. Java 리플렉션에 대해 설명해주세요.
`리플렉션(Reflection)`이란 런타임에 클래스, 메소드, 필드 등의 정보를 동적으로 검사하고 조작할 수 있는 기능을 `java.lang.reflect` 패키지를 통해 제공받고, 주로 프레임워크와 라이브러리에서 사용됩니다.

### 주요 기능
- 클래스의 메소드, 필드, 생성자 정보 조회
- 메소드 호출, 필드 값 설정/조회
- 클래스 및 객체의 동적 생성

<br>

## 23. Java의 Stream API에 대해 알고 있나요? 안다면 아는대로 설명해주세요.
`Stream API`란 Java 8에서 도입된 기능으로, 컬렉션 데이터를 처리하는 방법을 제공하며, 데이터를 일관성 있게 처리하기 위한 파이프라인을 형성한다.

### 주요 특징
- `지연 연산(lazy evaluation)`
- `병렬 처리(parallel processing)`
- `함수형 프로그래밍`

### 주요 메소드
- 중간 연산: `filter()`, `map()`, `sorted()`, `distinct()`
- 최종 연산`: `collect()`, `forEach()`, `reduce()`, `count()`

<br>

## 24. Java의 Fork-Join Pool이 무엇인지 설명해주세요.
`Fork-Join Pool`은 Java 7에서 도입된 프레임워크로, 큰 작업을 작은 작업으로 분할하고 작은 작업들을 병렬로 처리하여 성능을 향상시켜주는 역할을 한다.

### 주요 클래스
- `ForkJoinPool`: 작업 스레드를 관리하는 풀
- `ForkJoinTask`: 분할된 작업을 정의하는 클래스
- `RecursiveTask`: 결과를 반환하는 분할 작업
- `RecursiveAction`: 결과를 반환하지 않는 분할 작업

<br>

## 25. Java의 Optional이 무엇인지 설명해주세요.
`Optional`는 Java 8에서 도입된 클래스이며, null 값을 처리하는 데 사용된다.

`null`을 직접 다루는 대신 `Optional` 객체를 사용하여 값의 존재 여부를 명시적으로 처리할 수 있고, 주로 메소드의 반환 타입으로 사용되어 `null` 반환을 방지한다.

<br>

## 26. Java에서의 MultiThread 프로그래밍에 대해 설명해주세요.
`멀티스레드 프로그래밍`은 Java에서 여러 스레드가 동시에 실행되도록 할 수 있는 것을 말하며, 성능 향상, 응답성 개선, 자원 공유 등을 위해 사용된다.

### 스레드 생성 방법
- `Thread 클래스`를 상속하여 `run()` 메소드를 오버라이딩 
- `Runnable` 인터페이스를 구현하여 `run()` 메소드를 구현

<br>

## 27. 동기화가 무엇인지, Java에서 동기화 문제를 해결하는 방법에 대해 설명해주세요.
`동기화`는 여러 스레드가 동시에 공유 자원에 접근할 때 발생할 수 있는 문제를 방지하는 메커니즘으로, 데이터 일관성을 유지하고, *Race Condition을 방지한다.
- `Race Condition`: 여러 개의 프로세스가 공유 자원에 동시 접근할 때 실행 순서에 따라 결과값이 달라질 수 있는 현상

<br>

---

<br>

# Spring 관련 면접 질문 목록
## 1. Spring 프레임워크가 무엇인지 설명해주세요.
`스프링 프레임워크`는 자바 플랫폼을 위한 오픈 소스 어플리케이션 프레임워크로 POJO 기반을 바탕으로, DI와 AOP, PSA를 지원하는 경량의 컨테이너를 제공하는 프레임워크를 의미한다.

또한, 동적인 웹을 개발하기 위한 여러가지 서비스를 제공합니다.

<br>

## 2. IoC(Inversion of Control, 제어의 역전)이 무엇인지 설명해주세요.
객체의 생성부터 생명주기의 관리까지 모든 객체에 대한 제어권이 바뀐 것을 의미한다.

정확히 설명하면, 디자인 원칙 중 하나로 클래스간의 결합도를 줄이기 위해 다양한 종류의 제어를 반전시킬 것을 권장하는 것을 의미한다.

<br>

## 3. DI(Dependency Injection, 의존관계 주입)가 무엇인지 설명해주세요. 
`IoC`가 디자인 원칙이라면, `DI`는 `IoC`를 구현할 때 자주 등장하는 `디자인 패턴` 중 하나다. 

`DI`는 의존 관계 주입으로, 의존 객체를 직접 생성하는 것이 아니라, `생성자`나 `setter`를 통해 넣어줌으로써 의존 관계를 주입하는 것을 의미한다.

<br>

## 4. Spring에서 IoC와 DI를 어떻게 지원해 주는지에 대해 설명해주세요. 
스프링은 `IoC`와 `DI`를 `DI(IoC) Container`로써 제공하며, 클래스 사이의 의존 관계를 Bean 설정 정보를 바탕으로 컨테이너가 자동으로 연결해주는 방식으로 제공한다.

`DI 컨테이너`는 자바 객체의 생명 주기를 관리하며, 생성된 자바 객체들에게 추가적인 기능을 제공한다.

<br>

## 5. Bean 객체와 Bean 생명주기에 대해 설명해주세요.
`Bean 객체`는 DI 컨테이너 내부에 존재하며 관리를 받고 있는 객체를 의미하고, `@Bean` 어노테이션을 등록해 사용하거나 `xml`을 통해 등록할 수 있으며, Bean으로 등록된 객체는 쉽게 주입하여 사용이 가능하다.

`Bean 생명주기`는 아래와 같다.
- 스프링 컨테이너 생성 → 스프링 빈 생성 → 의존 관계 주입 → 초기화 콜백 → 사용 → 소멸 전 콜백 → 스프링 종료

<br>

## 6. Annotation에 대해 설명해주세요.
프로그램에게 추가적인 정보를 제공하는 메타데이터로, `annotation`을 정의하고, 원하는 위치에 배치한 후, 코드가 실행되는 도중 자바 리플렉션을 이용해 추가 정보를 획득해 기능을 실시하는 방식으로 동작된다.

Spring 컨테이너에서 객체가 호출되면, 객체의 인스턴스를 생성하게 되는데 이때 자바 리플렉션이 필요하게 된다.

<br>

## 7. Spring에서 제공하는 대표적인 Annotation 몇 가지만 예를 들어주세요. 
- `@Component`: 일반적인 스프링 빈을 정의할 때 사용
- `@Service`: 서비스 레이어에서 사용되는 빈을 정의할 때 사용
- `@Repository`: 데이터 접근 레이어에서 사용되는 빈을 정의할 때 사용
- `@Controller`: Spring MVC의 컨트롤러를 정의할 때 사용
- `@Autowired`: 의존성을 자동으로 주입할 때 사용
- `@Configuration`: 스프링 설정 클래스를 정의할 때 사용
- `@Bean`: 메소드를 통해 스프링 빈을 정의할 때 사용
- `@RequestMapping`: HTTP 요청을 특정 핸들러 메소드에 매핑할 때 사용

<br>

## 8. 웹 서버와 웹 애플리케이션 서버가 어떻게 다른지 알고 있나요?
![image](https://github.com/hamsangjin/TIL/assets/103736614/f54146b2-b33c-498f-b196-0b71342c0f76)

### 웹 서버
정적 리소스 파일을 제공하는 서버

### 웹 애플리케이션 서버(WAS)
- 웹 서버가 하는 일 + 애플리케이션 로직(DB 연결, 동작 수행, 데이터 제공)까지 제공하여 동적인 처리를 하는 서버
- 자바 진영에서는 서블릿 컨테이너 기능을 제공하면 `WAS`라고 한다.
- 위 그림에는 없지만 WAS 안에도 웹 서버가 따로 존재한다.

<br>

## 9. 서블릿과 서블릿 컨테이너에 대해서 설명해주세요.
![image](https://github.com/hamsangjin/TIL/assets/103736614/bc972c0e-a776-441f-aa69-f139b9cf1362)

### 서블릿(Servlet)
- `서블릿`은 자바 기반의 웹 애플리케이션에서 동적 웹 콘텐츠를 생성하는 서버 측 컴포넌트다.
- HTTP 요청을 받아 처리하고, HTTP 응답을 생성하여 클라이언트에 반환한다.
- 서블릿은 `javax.servlet` or `jakarta.servlet` 패키지에 정의되어 있으며, `HttpServlet` 클래스를 상속받아 구현합니다.

### 서블릿 컨테이너(Servlet Container)
- 서블릿을 실행하고 관리하는 환경을 제공한다.
- 서블릿의 생명주기 관리, 멀티스레딩 지원, 요청 및 응답 객체의 생성과 관리 등을 수행한다.
- 서블릿 컨테이너는 웹 애플리케이션 서버의 일부분으로, `Tomcat`, `Jetty`, `GlassFish` 등이 있다.

<br>

## 10. Spring MVC에 대해 설명해주세요.
![image](https://github.com/hamsangjin/TIL/assets/103736614/683736e5-192f-4687-9352-6e67a901c558)

Spring에서 제공하는 웹 모듈로, `Model/View/Controller` 세 가지 구성요소를 사용해 사용자의 다양한 `HTTP Request`를 처리하고 단순한 텍스트 형식의 응답부터 REST 형식의 응답은 물론, View를 표시하는 HTML을 Retrun하는 응답까지 다양한 응답을 할 수 있도록 도와주는 Framework다.

<br>

## 11. 하나의 컨트롤러로 여러 요청을 받을 수 있는 방법에 대해 설명해주세요. 
컨트롤러는 컴포넌트 스캔이 되면서 스프링 빈 컨테이너에 올라가고 또한, Bean 객체는 싱글톤 패턴으로 구현되어있기 때문에 여러 쓰레드의 요청이 들어와도 하나의 컨트롤러 객체를 공유하면서 처리한다. 

즉, 여러 쓰레드가 메서드에 대해 공유 자원으로써 접근해 사용한다.

주의할 점은, 싱글톤 패턴으로 구현되어있다는 점은, Thread-Safe하지 않다는 의미이므로, 상태를 공유하거나 저장하는 코드가 없도록 Stateless하게 정의해야 합니다.

<br>

## 12. 싱글톤 패턴은 무엇인가요?
`싱글톤 패턴`은 클래스의 인스턴스를 하나만 생성하고, 그 인스턴스에 접근할 수 있는 전역 접근점을 제공하는 디자인 패턴으로, 애플리케이션 전체에서 하나의 인스턴스만 필요할 때 사용된다.

<br>

## 13. AOP에 대해 설명해주세요.
`AOP`는 관점 지향 프로그래밍으로, 핵심 비즈니스 로직과 부가적인 관심사(로깅, 트랜잭션 관리 등)를 분리하여 코드의 모듈성을 향상시키는 프로그래밍 패러다임이다.

Spring AOP는 주로 프록시 패턴을 사용하여 부가적인 로직을 메소드 호출 전후에 추가한다.

<br>

## 14. POJO란 무엇인가요?
`Plain Old Java Object`의 약어로, 평범한 구식 자바 객체를 의미한다.

특정 프레임워크나 라이브러리에 종속되지 않은 간단한 자바 객체로, `getter`와 `setter` 메소드를 가질 수 있다.

Spring 프레임워크는 POJO 기반의 개발을 지향하여 애플리케이션 코드가 특정 프레임워크에 종속되지 않도록 한다.

<br>

## 15. DAO, DTO, BO, VO의 차이를 알고 있나요? 아는대로 설명해주세요.

### DAO(Data Access Object)
- DB 데이터를 조회하거나 조작하는 기능을 전담하는 객체
- DB 접근 로직과 비즈니스 로직을 분리하기 위해서 사용

### DTO(Data Transfer Object)
- 계층간의 데이터 교환을 위한 객체
- 로직을 갖지 않는 순수 데이터 객체로 getter, setter만 포함

### VO(Value Object)
- DTO와 동일한 개념
- Read Only로 수정 불가
- getter, setter 이외의 추가 로직 포함 가능

### BO(Business Object)
- 비즈니스 로직을 포함하는 오브젝트로, 여러 DAO를 사용해 데이터를 처리

<br>

## 16. Spring의 레이어드 아키텍처에 대해 설명해주세요.
![image](https://github.com/hamsangjin/TIL/assets/103736614/500bce57-d462-474b-bc75-34f0d87f1eb5)

`Spring의 레이어드 아키텍처`는 전형적인 엔터프라이즈 애플리케이션을 쉽게 개발할 수 있도록 여러 계층으로 구성된 아키텍처를 의미하고, 각 계층은 특정 책임을 맡으며, 서로 분리되어 있어 코드의 모듈성과 유지보수성을 높인다.

- `Presentation Layer`: view를 담당하는 부분으로, 클라이언트와 직접적으로 맞닿는 부분
- `Application Layer`: 비즈니스 핵심 로직을 처리하는 부분으로, Service 객체라는 것은 하나의 트랜잭션으로 구성되어 작동
- `Persistence Layer`: 데이터 관련 처리를 담당하는 부분

<br>

## 17. 커넥션 풀이 무엇인지, Spring Boot에서의 커넥션 풀로는 어떤 것을 사용하는지 설명해주세요.
어플리케이션이 DB를 사용하기 위해서는 `Connection`이 필요한데, 이 생성 및 소멸 비용이 크기 때문에, 커넥션 풀을 미리 생성하고 애플리케이션이 시작하는 시점에 커넥션을 미리 다 생성하고 이것을 재활용하며 사용하게 된다.

Springboot 2.0 이후 부터는 `hikariCP`를 `기본 CP`로 사용합니다.

<br>

## 18. DataSource는 무엇인가요?
Connection 관련 기술이 많아지면서, 코드 레벨에서는 다르지만 논리적으로는 커넥션을 획득하는 역할을 하기 때문에 이를 추상화 시킨 것을 `DataSource`라 한다.

실질적인 로직을 `DataSource`에 의존하도록 하고, 구현 기술이 바뀌면 `DataSource`의 구현체만 바꾸면 되므로, 재사용성과 확장성을 높일 수 있습니다.

<br>

## 19. 트랜잭션을 추상화해서 사용하는 이유를 알고 있나요?
다양한 데이터 접근 기술이 등장하면서, 코드레벨에서는 다르지만 논리적으로는 같은 기능을 수행하기 때문에 트랜잭션을 추상화했다. 

다양한 접근 기술로는 `JDBC`, `JPA`, `하이버네이트` 등이 있다.

<br>

## 20. 트랜잭션 동기화 매니저의 역할에 대해 아는대로 설명해주세요.
보통 서비스 단에서 트랜잭션을 시작하고 끝내게 되는데, 그렇다면 하나의 트랜잭션 내에서는 같은 커넥션을 사용해야 되며 과정은 다음과 같다.

- 서비스단에서 트랜잭션이 시작하면 트랜잭션 매니저가 커넥션을 생성하고(풀을 사용하면 풀에서 가져오고) autoCommit을 false로 세팅한 뒤 트랜잭션 동기화 매니저의 스레드 로컬에 커넥션을 보관
- 이후 리포지토리 계층에서는 트랜잭션 동기화 매니저의 스레드 로컬에서 해당 커넥션을 가져와서 사용
- 서비스 단에서 트랜잭션을 종료할 때는 트랜잭션 동기화 매니저에서 해당 커넥션을 가져와 커밋 또는 롤백을 수행하고 리소스를 정리하고 커넥션을 커넥션 풀에 반환

하나의 트랜잭션에서 같은 커넥션을 사용하도록 도움을 주는 기능을 제공한다고 보면 됩니다.

<br>

## 21. Spring을 사용해 트랜잭션을 적용하는 방법 2가지에 대해 설명해주세요.

### 애노테이션 기반 트랜잭션 관리
가장 일반적으로 사용되는 방식으로, `@Transactional` 애노테이션을 사용하여 메소드 또는 클래스 수준에서 트랜잭션을 선언적으로 관리한다.

### 프로그래매틱 트랜잭션 관리
트랜잭션을 코드 내에서 직접 관리하는 방식으로, `PlatformTransactionManager`와 `TransactionTemplate`을 사용하며, 유연성과 제어가 필요한 상황에서 사용된다.

<br>

## 22. JDBC, Spring JDBC, MyBatis, ORM, JPA, Hibernate, Spring Data JPA에 대해 각각 설명해주세요.
### JDBC (Java Database Connectivity)
- 자바에서 데이터베이스와의 통신을 위한 표준 API
- SQL 쿼리를 직접 작성하고 실행하며, 결과를 수동으로 처리한다.

### Spring JDBC
- Spring 프레임워크에서 제공하는 JDBC 지원 라이브러리
- JDBC의 반복적인 코드 패턴을 줄이고, 예외 처리를 간편하게 한다.
- JdbcTemplate 클래스를 사용하여 간편하게 JDBC 작업을 수행한다.

### MyBatis
- SQL 매퍼 프레임워크로, SQL 쿼리를 XML 파일이나 애노테이션으로 관리한다.
- 자바 객체와 SQL 문을 매핑하며, SQL의 유연성을 제공한다.
- 직접 SQL을 작성하지만, 객체 매핑을 자동으로 처리한다.

### ORM(Object-Relational Mapping)
- 객체와 관계형 데이터베이스 간의 데이터를 자동으로 매핑해주는 기술
- 데이터베이스 테이블과 객체 간의 매핑을 통해, SQL을 직접 작성하지 않고도 데이터베이스 작업을 수행할 수 있다.

### JPA (Java Persistence API)
- 자바 표준 ORM API로, 객체와 데이터베이스 간의 매핑을 제공
- 엔터티(Entity) 클래스를 사용하여 데이터베이스 테이블을 매핑하고, JPQL(Java Persistence Query Language)을 사용하여 쿼리를 작성한다.

### Hibernate
- JPA의 레퍼런스 구현체 중 하나로, 강력한 ORM 프레임워크
- 다양한 기능과 유연성을 제공하며, JPA 표준을 준수한다.

### Spring Data JPA
- Spring 프레임워크에서 제공하는 JPA를 간편하게 사용할 수 있도록 지원하는 라이브러리
- 리포지토리 인터페이스를 통해 CRUD 및 복잡한 쿼리를 쉽게 작성할 수 있다.

<br>

## 23. 영속성 컨텍스트(Persistence Context)는 무엇인가요?
`영속성 컨텍스트`는 JPA에서 엔티티 객체를 관리하는 환경을 뜻하며, 엔티티 매니저(Entity Manager)가 영속성 컨텍스트를 관리한다.

또한, 특정 엔티티 인스턴스를 데이터베이스와 동기화하여, 동일 트랜잭션 내에서 엔티티의 상태를 유지하고 변경 사항을 반영한다.

### 특징
- `1차 캐시`: 영속성 컨텍스트는 1차 캐시 역할을 하여, 동일 트랜잭션 내에서 동일한 엔티티를 반복 조회할 때 데이터베이스 조회를 줄인다.
- `변경 감지`: 트랜잭션이 커밋되기 전에 엔티티의 변경 사항을 감지하여 자동으로 데이터베이스에 반영한다.
- `지연 로딩`: 필요할 때까지 데이터베이스에서 엔티티를 로드하지 않고, 참조할 때 로딩한다.

<br>

## 24. JPA N+1 문제에 대해 알고 계신가요? 문제와 해결 방법에 대해 설명해주세요.
`N+1 문제`란 JPA에서 발생하는 성능 문제 중 하나로, 연관된 엔티티를 조회할 때 발생한다.

예를 들어, 1개의 부모 엔티티를 조회한 후, 각 부모 엔티티와 연관된 자식 엔티티를 각각 조회할 때 발생하고, 결과적으로 1번의 부모 엔티티 조회와 N번의 자식 엔티티 조회가 이루어진다.

### 해결 방법
- `페치 조인(Fetch Join)`: JPQL에서 join fetch를 사용하여 한 번의 쿼리로 연관된 엔티티를 함께 조회한다.
- `Entity Graph`: 엔티티 그래프를 사용하여 필요한 엔티티와 연관된 엔티티를 한 번에 로드한다.

<br>

## 25. 객체 간의 상속관계를 DB에 적용시키기 위해서는 어떻게 해야 할까요?
JPA에서는 객체 간의 상속관계를 데이터베이스에 적용하기 위해 세 가지 전략을 제공한다.

1. `단일 테이블 전략(Single Table Strategy)`: 모든 상속 관계의 엔티티를 하나의 테이블에 저장하며, 구분 컬럼(DTYPE)으로 각 엔티티 유형을 구분한다.
2. `조인 전략(Joined Strategy)`: 상위 클래스와 하위 클래스 각각의 테이블을 생성하고, 상위 클래스의 기본 키를 외래 키로 사용하여 테이블을 연결한다.
3. `테이블 퍼 클래스 전략(Table per Class Strategy)`: 각 클래스마다 개별 테이블을 생성하며, 상속 관계의 모든 속성을 테이블에 포함한다.
