# Spring 입문 - 스프링 DB 접근기술

> 인프런의 "스프링 입문 - 코드로 배우는 스프링 부트, 웹 MVC, DB 접근 기술" 강의를 듣고 정리한 내용입니다.

## 목차
- [H2 데이터베이스 설치](#H2-데이터베이스-설치)
- [순수 Jdbc](#순수-Jdbc)
- [스프링 통합 테스트](#스프링-통합-테스트)
- [스프링 JdbcTemplate](#스프링-JdbcTemplate)
- [JPA](#JPA)
- [스프링 데이터 JPA](#스프링-데이터-JPA)

</br>

---

## H2 데이터베이스 설치

### 설치 및 실행

먼저 [https://www.h2database.com/html/download-archive.html](https://www.h2database.com/html/download-archive.html)에서 1.4.200 버전을 설치해준다.

그 후, terminal에서 h2/bin/h2.sh 파일을 명령어 `chmod 755 h2.sh`을 통해 권한 변경을 하고 명령어 `./h2.sh`를 이용해 실행시킨다.

실행시키게 되면 아래 창이 뜬다.
<p align=center>
<img width="711" alt="스크린샷 2024-01-05 14 22 10" src="https://github.com/hamsangjin/TIL/assets/103736614/736d6dba-b7ac-4d22-b219-b7d835870eac">
</p>

- `JDBC URL` : 파일의 경로

</br>

먼저 아무것도 건드리지 않고 연결을 한다.
<p align=center>
<img width="898" alt="스크린샷 2024-01-05 14 28 17" src="https://github.com/hamsangjin/TIL/assets/103736614/810a2b90-b474-4cbb-8960-d2baf5555e4f">
</p>

위 창이 뜨면 잘 연결된 것이고, 가장 왼쪽 위 버튼을 통해 연결 전 창을 다시 띄운 후, 
</br>
지금처럼 `JDBC URL`을 파일로 설정하게 되면 오류가 날 수 있으므로, `jdbc:h2:tcp://localhost/~/test`로 경로를 변경해 파일에 직접 접근하는 것이 아니라 소켓을 통해 접근할 수 있게 변경해준다.
</br>
그 후 로컬에 test.mv.db가 생성하는지 삭제 후 확인해보고 생성된다면 정상 작동되는 것이다.

### 테이블 생성
기존에 진행했었던 `member` 테이블을 생성해보자.
<p align=center>
<img width="462" alt="스크린샷 2024-01-05 14 45 09" src="https://github.com/hamsangjin/TIL/assets/103736614/d6bc6120-3aaf-4311-b66f-04aa94231808">
</p>

왼쪽을 보면 쿼리문에 따라 `member`라는 테이블이 생성된 것을 볼 수 있다.

- `bigint` : java의 long과 동일
- `generated by default as identity` : 먼저 값을 세팅하지 않고, 데이터가 삽입됐을 때 자동으로 값을 채워줌
- `varchar` : 가변길이 문자열을 의미

</br>


이제 `member` 테이블에 값을 삽입해보고 조회해 확인해보자.
<p align=center>
<img width="273" height="300" alt="스크린샷 2024-01-05 14 53 46" src="https://github.com/hamsangjin/TIL/assets/103736614/c2148147-fe54-4a06-9c98-a03da4205e3e">
<img width="273" height="300" alt="스크린샷 2024-01-05 14 55 53" src="https://github.com/hamsangjin/TIL/assets/103736614/562adcb0-6523-4ecc-81fe-090d1290da2b">
</p>

정상적으로 삽입되며, id값이 자동으로 추가된 걸 확인할 수 있다.

</br>


이제 이러한 sql문도 같이 관리하기 위해 `hello-spring/sql` 폴더에 `ddl.sql`이라는 파일을 생성해 아까 작성한 쿼리문을 저장해 관리한다.
<p align=center>
<img width="786" alt="스크린샷 2024-01-05 15 04 53" src="https://github.com/hamsangjin/TIL/assets/103736614/68d948b2-ca8d-4077-b588-af6d02b93284">
</p>

--- 

## 순수 Jdbc


### Jdbc 환경설정
> 지금 진행하는 것은 오래된 방법이라, 이런 식으로 사용했었구나 ~ 라는 식으로 가볍게 듣는 것이 좋다.


먼저 `build.gradle` 파일에 `jdbc`, `h2 데이터베이스` 관련 라이브러리를 추가해주자
<p align=center>
<img width="964" alt="스크린샷 2024-01-05 15 13 59" src="https://github.com/hamsangjin/TIL/assets/103736614/2243c850-6222-4533-9d00-586e8479185a">
</p>

* java는 DB랑 연결하려면 JDBC 드라이버가 꼭 있어야 한다.

</br>

이제 DB와 연결하기 위해서는 접속 정보가 필요한데, 스프링 부트에서는 `application.properties`에 경로만 넣으면 드라이버 설치 세팅이 끝난다.
<img width="767" alt="스크린샷 2024-01-05 15 37 13" src="https://github.com/hamsangjin/TIL/assets/103736614/db4541e9-edde-45e6-aae8-c12d5259bffe">
* 스프링부트 2.4부터 `spring.datasource.username=sa`을 추가해야 오류가 발생 안 한다.

### Jdbc 리포지토리 구현

먼저 전에 생성했었던 구현체 `MemberRepository`를 이용해 메소드들을 불러오고 수정해준다.

- main/java/hello/hellospring/repository/JdbcMemberRepository.java
```java
package hello.hellospring.repository;

import hello.hellospring.domain.Member;
import org.springframework.jdbc.datasource.DataSourceUtils;

import javax.sql.DataSource;
import java.sql.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

public class JdbcMemberRepository implements MemberRepository {
    private final DataSource dataSource;

    public JdbcMemberRepository(DataSource dataSource) {
        this.dataSource = dataSource;
    }

    @Override
    public Member save(Member member) {
        String sql = "insert into member(name) values(?)";

        Connection conn = null;
        PreparedStatement pstmt = null;
        ResultSet rs = null;
        ...
```
</br>

### 스프링 설정 변경

지금까지는 Spring Config에서 `MemoryMemberRepository`를 스프링 빈에 등록해 사용하고 있었다.

하지만 이제 h2 데이터베이스를 사용해 동작해야하니까 `MemoryMemberRepository`이 아닌 `JdbcMemberRepository`로 변경해준다.

- `DataSource` : 데이터베이스 커넥션을 획득할 때 사용하는 객체로, 스프링 부트는 데이터베이스 커넥션 정보를 바탕으로 DataSource를 생성하고 스프링 빈으로 만들어둔다. 그래야 DI(의존성 주입)을 받을 수 있다.

- main/java/hello/hellospring/service/SpringConfig.java
```java
package hello.hellospring.service;

import hello.hellospring.repository.JdbcMemberRepository;
import hello.hellospring.repository.MemberRepository;
import hello.hellospring.repository.MemoryMemberRepository;
import hello.hellospring.service.MemberService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import javax.sql.DataSource;

@Configuration
public class SpringConfig {

    private final DataSource dataSource;

    @Autowired
    public SpringConfig(DataSource dataSource) {
        this.dataSource = dataSource;
    }

    @Bean
    public MemberService memberService() {
        return new MemberService(memberRepository());
    }

    @Bean
    public MemberRepository memberRepository(){
//        return new MemoryMemberRepository();
        return new JdbcMemberRepository(dataSource);
    }
}
```

</br>

현재 변경한거라고는 `SpringConfig` 설정과 H2 드라이버 설치만 진행했다. </br>
이때, 메모리로 동작하던 코드가 h2 데이터베이스를 이용해 동작하는지 확인해보자. </br>

회원에 함상진을 추가하고, 회원 목록을 확인해보자.
<p align=center>
<img width="331" height="330 alt="스크린샷 2024-01-06 17 41 35" src="https://github.com/hamsangjin/TIL/assets/103736614/c898ef60-aab9-4577-afc8-078233766a4d">
<img width="331" height="330 alt="스크린샷 2024-01-06 17 39 37" src="https://github.com/hamsangjin/TIL/assets/103736614/7370dff5-bb24-4208-8c37-9270195022a6">
</p>

</br>

기존에 등록했던 **spring1**, **spring2**와 새로운 회원 **함상진**이 추가된 걸 볼 수 있다.

</br>

### 구현 클래스 추가 이미지
<p align=center>
<img width="601" alt="스크린샷 2024-01-06 17 48 22" src="https://github.com/hamsangjin/TIL/assets/103736614/801ef4a5-1c2b-4d1f-8295-b7fa246974f5">
</p>

- `다형성` : 인터페이스를 가지고 이것저것 구현할 수 있는 기능으로, 스프링 컨테이너가 지원을 해주며, DI를 통해 쉽게 할 수 있다. 

</br>

### 스프링 설정 이미지
<p align=center>
<img width="597" alt="스크린샷 2024-01-06 17 50 41" src="https://github.com/hamsangjin/TIL/assets/103736614/35a9c041-cbca-47bc-864a-78a0e6fcd20e">
</p>
</br>

- `개방 폐쇄 원칙(OCP, Open-Closed Principle)` : SOLID 중 하나로, 확장에는 열려있고, 수정(변경)에는 닫혀있다.
- 스프링의 DI를 사용하면 기존 코드를 **전혀 손대지 않고, 설정만으로 구현 클래스를 변경**할 수 있다.
- 이제 **메모리**가 아닌 DB에 저장하므로 서버를 다시 실행해도 데이터가 안전하게 저장되어 있다.

</br>

## 스프링 통합 테스트

스프링 컨테이너와 DB까지 연결했으니 이제 통합 테스트를 해보자

### 회원 서비스 스프링 통합테스트

> 기존에 했었던 테스트들은 순수 java 코드를 가지고 테스트를 했었지만, </br>
> 이제는 스프링부트가 데이터베이스 커넥션 정보를 들고있기 때문에 스프링을 이용해 통합테스트를 해야한다.

- test/java/hello/hellospring/service/MemberServiceIntegrationTest.java
```java
package hello.hellospring.service;

import hello.hellospring.domain.Member;
import hello.hellospring.repository.MemberRepository;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.transaction.annotation.Transactional;

import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.jupiter.api.Assertions.assertThrows;

@SpringBootTest
@Transactional
class MemberServiceIntegrationTest {

    @Autowired MemberService memberService;
    @Autowired MemberRepository memberRepository;

    @Test
    void 회원가입() {
        // given : 상황이 주어졌을 때
        Member member = new Member();
        member.setName("test");

        // when : 이거를 실행했을 때
        Long saveId = memberService.join(member);

        // then : 이거가 나와야 해
        Member findMember = memberService.findOne(saveId).get();
        assertThat(member.getName()).isEqualTo(findMember.getName());
    }

    @Test
    public void 중복_회원_예외() {
        // given
        Member member1 = new Member();
        member1.setName("test");

        Member member2 = new Member();
        member2.setName("test");
        // when
        memberService.join(member1);

        IllegalStateException e = assertThrows(IllegalStateException.class, () -> memberService.join(member2));

        assertThat(e.getMessage()).isEqualTo("이미 존재하는 회원입니다.");
    }
}
```

</br>

- `@SpringBootTest` : 스프링 컨테이너와 테스트를 함께 실행하기 위한 어노테이션
- `@Transactional` : 테스트 시작 전에 **트랜잭션을 시작**하고, 테스트 완료 후에 항상 **롤백**을 해주는 어노테이션. 이렇게 하면 DB에 데이터가 남지 않으므로 다음 테스트에 영향을 주지 않는다.
  - 기존 테스트의 `@AfterEach`와 비슷한 역할을 한다.
  - `@Transactional`을 사용했을 때와 안 했을 때의 DB 조회 결과
  
<p align=center>
<img width="274" height="300" alt="스크린샷 2024-01-10 15 14 54" src="https://github.com/hamsangjin/TIL/assets/103736614/143152a1-b5d3-4e49-ae0c-4f0e34b229c2">
<img width="274" height="300" alt="스크린샷 2024-01-10 15 14 29" src="https://github.com/hamsangjin/TIL/assets/103736614/f6a1e64d-82df-4e94-8ee6-87bee3ee491f">
</p>

</br>

## 스프링 JdbcTemplate

### 스프링 JdbcTemplate 회원 리포지토리
