# Spring 입문 - 스프링 웹 개발 기초

> 인프런의 "스프링 입문 - 코드로 배우는 스프링 부트, 웹 MVC, DB 접근 기술" 강의를 듣고 정리한 내용입니다.

## 목차
- [정적 컨텐츠](#정적-컨텐츠)
- [MVC와 템플릿 엔진](#MVC와-템플릿-엔진)
- [API](#API)

- [회원 관리 예제(백엔드 개발)](#회원-관리-예제(백엔드-개발))
  - [비즈니스 요구사항 정리](#비즈니스-요구사항-정리)
  - [회원 도메인과 리포지토리 만들기](#회원-도메인과-리포지토리-만들기)

<!--
  - [회원 리포지토리 테스트 케이스 작성](#회원-리포지토리-테스트-케이스-작성)
  - [회원 서비스 개발](#회원-서비스-개발)
  - [회원 서비스 테스트](#회원-서비스-테스트)

-->


## 정적 컨텐츠

> 정적컨텐츠 : html파일 자체를 그대로 웹브라우저에 전달해주는 방식

Spring Boot에서 정적컨텐츠 기능을 자동으로 제공

제공 주소 : [Link](https://docs.spring.io/spring-boot/docs/2.3.1.RELEASE/reference/html/spring-boot-features.html#boot-features-spring-mvc-static-content)

</br>

내가 보여주고 싶은 화면을 아래의 위치에 hello-static이라는 이름으로 만들었다.
- resources/static/hello-static.html
```html
  <!DOCTYPE HTML>
  <html>
  <head>
      <title>static content</title>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  </head>
<body>
정적 컨텐츠 입니다.
  </body>
  </html>
```

</br>

현재 서버 포트가 8080이므로, localhost:8080/hello-static.html을 브라우저에서 요청한다.

- `실행 결과(http://localhost:8080/hello-static.html)`
<img width="399" alt="정적컨텐츠 실행결과" src="https://github.com/hamsangjin/TIL/assets/103736614/6e05964f-73cb-4adb-8694-e2a623343405">

</br>
</br>

그러면, 위와 같이 생성한 html파일을 볼 수 있다.</br>
이렇게 정적컨텐츠는 resources/static폴더에서 요청한 html파일을 가져와 브라우저에 보여준다.</br>
그래서 html파일화면만 볼 수 있다는 단점이 존재한다.</br>


- 동작 원리
<img width="549" alt="정적 컨텐츠 동작 원리" src="https://github.com/hamsangjin/TIL/assets/103736614/56f34cda-7d34-49c7-89be-2f86aa5183c2">

웹브라우저에서 내장톰캣서버에게 localhost:8080/hello-static.html 요청을 하면 내장톰캣서버가 스프링 컨테이너에게 전달해준다. </br>
그러면 먼저 스프링 컨테이너가 우선순위를 가지고있는 컨트롤러에서 hello-static이 있는지 확인한다. </br>
확인해보고 지금과 같이hello-static과 맵핑이 되어있는 컨트롤러를 찾지 못하면 resources/static에서 hello-static.html 파일이 있는지 확인한 후, 웹 브라우저에 전달해준다.

</br>
</br>
</br>

## MVC와 템플릿 엔진

> MVC : Model, View, Controller의 약자이며, 하나의 애플리케이션이나 프로젝트를 구성할 때 그 구성요소를 세 가지의 역할로 구분한 패턴이다.

1. Model : 애플리케이션의 정보, 데이터를 나타내며, 데이터베이스, 처음에 정의하는 상수, 초기화 값, 변수 등을 뜻한다.
2. View : 입력 텍스트, 체크박스 항목 등과 같은 사용자 인터페이스 요소를 나타낸다.
3. Controller : 사용자가 데이터를 클릭하고, 수정하는 것에 대한 이벤트들을 처리하는 부분을 뜻한다.

</br>

여기서의 Controller와 View 파일은 아래와 같다.

- java/hello.hellospring/controller/HelloController.java

```java
  @Controller
  public class HelloController {
      @GetMapping("hello-mvc")
      public String helloMvc(@RequestParam("name") String name, Model model) {
          model.addAttribute("name", name);
          return "hello-template";
      }
}
```

- resources/templates/hello-template.html
```html
  <html xmlns:th="http://www.thymeleaf.org">
  <body>
  <p th:text="'hello ' + ${name}">hello! empty</p>
  </body>
```

</br>

- `실행결과(http://localhost:8080/hello-mvc?name=spring)`
<img width="386" alt="MVC 실행결과" src="https://github.com/hamsangjin/TIL/assets/103736614/68b835ca-1e19-472d-b7c4-b2f0d4769b49">

</br>

- `@GetMapping("hello-mvc")` : GET방식이며, "hello-mvc"로 호출하는 것으로 정의해놓은 것이다.
- `@RequestParam(value="",required="")` : 호출할 때 파라미터를 정의한 것이다. 코드를 보면 @RequestParam("name") String name으로 되어있다. 즉, 파라미터를 name이라는 key로 String 데이터를 받겠다라는 의미다. 그래서 실행하는 url을 보면 name=spring으로 호출하고, 데이터 처리를 할 때는 spring이라는 데이터가 들어와 동작하게되는 것이다.
  - `required`의 **default는 true**, 파라미터가 필수가되어야하는 의미이기 때문에 false를 넣어주면 있어도 없어도 동작할 수 있다.
- `<p th:text="'hello ' + ${name}">hello! empty</p>` : **템플릿 엔진**을 사용해 name이라는 데이터(spirng)가 넘어왔을 때 `hello spring`이 보여지고 만약 데이터가 없다면 그냥 `hello!`가 보여진다.

</br>

- 동작 원리
<img width="543" alt="MVC 동작 원리" src="https://github.com/hamsangjin/TIL/assets/103736614/c16a7d0c-694b-446e-b8fd-db1875fc73bf">

1. Get요청(http://localhost:8080/hello-name?name=spring) : 스프링 프로젝트에서 해당 컨트롤러
를 생성한 후에, 브라우저에서 작성한 주소를 호출하는 것

2. 내장톰캣서버에 요청 후 스프링컨테이너에 전달한다.

3. 스프링 컨테이너에서는 HelloController에 맵핑되어있는 것을 확인하고 hello-template에 모델을 리턴

4. ViewResolver가 리턴한 hello-template을 찾아서 템플린엔진에게 처리해달라고 요청한다.
  - **ViewResolver**는 화면을 찾아주고, 템플릿엔진을 연결시켜주는 역할

5. 템플릿 엔진은 동적으로 넘어온 데이터를 치환하여 변경하고, html로 변환하여 전달한다.


</br>
</br>
</br>

## API

> API(Application Programming Interface) : 정의 및 프로토콜 집합을 사용하여 두 소프트웨어 구성 요소가 서로 통신할 수 있게 하는 메커니즘

이번엔 컨트롤러에 `@ResponseBody`를 이용해 문자를 반환해보자.

- java/hello.hellospring/controller/HelloController.java

```java
 @Controller
  public class HelloController {
      @GetMapping("hello-string")
      @ResponseBody
      public String helloString(@RequestParam("name") String name) {
          return "hello " + name;
      }
  }
```

- `실행결과(http://localhost:8080/hello-string?name=spring!!!!!!!)`
<img width="483" alt="스크린샷 2023-11-28 21 27 17" src="https://github.com/hamsangjin/TIL/assets/103736614/d6fc6a9d-c02a-4122-bf2b-e7de5d45d22e">

- @ResponseBody : Http 통신 프로토콜엔 Header부와 Body부가 있는데, 그 중 Body부에 데이터`("hello " + name)`를 직접 넣어주겠다는 뜻이며, 템플린 엔진과는 다르게 viewResolver를 사용하지 않는다.

- 이렇게 사용한다면 아래 사진과 같이 Http Body에 문자 내용을 직접 반환한다.

- `ResponseBody의 Http Body`
<img width="204" alt="스크린샷 2023-11-28 21 31 37" src="https://github.com/hamsangjin/TIL/assets/103736614/1f9c60af-ef72-44dd-8875-b8a2c055bbdb">

- `기존 MVC의 Http Body`
<img width="174" alt="스크린샷 2023-11-28 21 28 59" src="https://github.com/hamsangjin/TIL/assets/103736614/faf19076-5e85-4b9f-9000-446053f3f9d0">

* 하지만 문자를 반환하는 방법을 쓸 일은 거의 없다.

---

이제 @ResponseBody를 이용해 객체를 반환하는 방법을 사용해보자
- java/hello.hellospring/controller/HelloController.java

```java
@Controller
public class HelloController {
    @GetMapping("hello-api")
    @ResponseBody
    public Hello helloApi(@RequestParam("name") String name) {
        Hello hello = new Hello();
        hello.setName(name);
        return hello;
    }
    static class Hello {
        private String name;
        public String getName() {
            return name;
        }
        public void setName(String name) {
            this.name = name;
        }
    }
}
```

- `Tip` :  Mac OS 기준으로 `cmd + n`을 누르면 generate가 나오는데 거기서 getter and setter를 선택하면 `getName()`과 `setName()` 메소드를 입력할 수 있다. 이것을 JavaBean 규약이라고 하며, property 접근 방식이라고도 한다.

- `실행결과(http://localhost:8080/hello-api?name=spring!!!!!!!)`
<img width="397" alt="스크린샷 2023-11-28 21 48 14" src="https://github.com/hamsangjin/TIL/assets/103736614/14688221-89b1-4e23-a33f-b3e7562391bb">

- 이렇게 객체를 반환하게 되면 객체가 JSON 형식으로 변환되어 반환된다.

> JSON : 속성-값 쌍, 배열 자료형 또는 기타 모든 시리얼화 가능한 값 또는 Key-Value 쌍으로 이루어진 데이터 오브젝트를 전달하기 위해 인간이 읽을 수 있는 텍스트를 사용하는 개방형 표준 포맷이다.

- @ResponseBody를 사용한 API 방식의 사용 원리
<img width="589" alt="스크린샷 2023-11-28 21 52 42" src="https://github.com/hamsangjin/TIL/assets/103736614/5cade8d4-acbb-484f-a540-2a0bd7f7e40c">

1. 웹브라우저에서 `localhost:8080/hello-api`를 요청하면 내장 톰켓 서버가 받아서 스프링 컨테이너에 넘겨준다.
2. 스프링 컨테이너는 Hello-Controller에서 매핑되어있는 걸 확인하고, ResponseBody라는 애노테이션이 붙어있으므로 기존 방법과 달리 ViewResolver한테 넘기지 않고 HTTP 응답에 데이터를 넣는 식으로 동작한다.
3. 만약 데이터가 문자라면 Http Message Converter 중 String Converter가 동작하고, 객체라면 Json Converter가 동작해 json방식으로 데이터를 만들어준다.
4. 그렇게 만들어진 데이터를 요청한 웹브라우저로 보내준다.

* json이 아닌 xml로도 반환받을 수 있다.


----

## 회원 관리 예제(백엔드 개발)

### 비즈니스 요구사항 정리

우리가 구현할 회원 관리 예제의 요구사항은 아래와 같다.
- 데이터 : 회원 ID, 이름
- 기능 : 회원 등록, 조회
- 데이터 저장소는 선정되지 않았다고 가정

</br>

* 일반적인 웹 애플리케이션 계층 구조
<img width="587" alt="스크린샷 2023-11-29 20 49 11" src="https://github.com/hamsangjin/TIL/assets/103736614/abb90c59-4f02-4889-9080-5635d1d5efb5">

- 컨트롤러 : 웹 MVC의 컨트롤러 역할
- 서비스 : 핵심 비즈니스 로직 구현
- 리포지토리 : 데이터베이스에 접근하고, 도메인 객체를 DB에 저장하고 관리
- 도메인 : 비즈니스 도메인 객체 (ex: 회원, 주문 등 주로 데이터베이스에 저장하고 관리됨)

</br>

구현할 회원 관리 예제의 클래스 의존관계는 아래와 같다.
<img width="582" alt="스크린샷 2023-11-29 20 58 09" src="https://github.com/hamsangjin/TIL/assets/103736614/28e5e797-caf0-4904-a423-e919879d9150">

- 데이터 저장소가 선정되지 않아서, 먼저 인터페이스로 구현 클래스를 변경할 수 있게 설계했으며, 개발을 진행하기 위해 초기 개발 단계에서는 구현체로 가벼운 메모리 기반의 데이터 저장소 사용

---

### 회원 도메인과 리포지토리 만들기

#### 회원 객체

먼저 java/hello.hellospring에 domain이란 이름의 패키지를 만들고 그 안에 Member.java(class) 파일을 생성한다.

- java/hello.hellospring/domain/Member.java

```java
package hello.hellospring.domain;
public class Member {
    private Long id;
    private String name;

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
```

- 여기서도 generate에 getter and setter를 이용해 메소드들을 불러왔다.

#### 회원 리포지토리 인터페이스

이번엔 java/hello.hellospring에 repository란 이름의 패키지를 만들고 그 안에 MemberRepository.java(interface) 파일을 생성한다.

</br>

> **배워가는 JAVA 시간 !** 
> * `Interface` : 다른 클래스를 작성할 때 기본이 되는 틀을 제공하면서, 다른 클래스 사이의 중간 매개 역할까지 담당하는 일종의 추상 클래스를 의미한다.
>   - 다중 상속 가능
>   - 추상 메소드와 상수로만 구성
>   - 메소드 오버라이딩 필수

</br>

- java/hello.hellospring/repository.MemberRepository.java

```java
package hello.hellospring.repository;

import hello.hellospring.domain.Member;

import java.util.List;
import java.util.Optional;

public interface MemberRepository {
      Member save(Member member);
      Optional<Member> findById(Long id);
      Optional<Member> findByName(String name);
      List<Member> findAll();
}
```

</br>

#### 회원 리포지토리 메모리 구현체
이제 MemberRepository를 상속한 MemoryMemberRepository 클래스를 만들고, option + enter를 통해 인터페이스에 생성한 메소드들을 선언한다.

- java/hello.hellospring/repository.MemoryMemberRepository.java

```java

package hello.hellospring.repository;
import hello.hellospring.domain.Member;
import java.util.*;
public class MemoryMemberRepository implements MemberRepository {
    private static Map<Long, Member> store = new HashMap<>();
    private static long sequence = 0L;

    @Override
    public Member save(Member member) {
        member.setId(++sequence);
        store.put(member.getId(), member);
        return member;
    }

    @Override
    public Optional<Member> findById(Long id) {
        return Optional.ofNullable(store.get(id));
    }

    @Override
    public List<Member> findAll() {
        return new ArrayList<>(store.values());
    }

    @Override
    public Optional<Member> findByName(String name) {
        return store.values().stream()
                .filter(member -> member.getName().equals(name))
                .findAny();
    }

    public void clearStore() {
        store.clear();
    }
}
```

> **배워가는 JAVA 시간 !** 
> * `Map` : 사전형과 비슷하며 Key와 Value을 한 쌍으로 갖는 자료형이다.
>   - `HashMap` : Map 자료형 중 가장 기본이며, put 메소드로 key와 value를 추가할 수 있고, get 메소드로 key에 해당하는 value를 얻을 수 있다.
> * `Optional` : Java 8부터 도입된 Optional은 값이 없는 경우를 표현하기 위한 클래스이며, Optional 클래스는 제네릭을 사용하여 어떤 타입의 객체도 감싸서 담을 수 있다.
>   - `of()` : 값이 null이 아닌 경우에만 Optional 객체를 생성
>   - `ofNullable()` : 값이 null인 경우에도 Optional 객체를 생성.
>   - `empty()` : 값을 갖지 않는 빈(empty) Optional 객체를 생성
> * `stream` : 컬렉션 형태로 구성된 데이터를 람다 함수를 이용해 쉽게 처리할 수 있으며 기존 loop를 대체할 수 있다.
>   - `filter` : stream 클래스에서 제공하며, 스트림 요소를 순회하면서 특정 조건을 만족하는 요소로 구성된 새로운 스트림을 반환합니다.
>     - `->` : 자바 람다표현식의 syntax
>     - `findAny()` : 조건에 일치하는 요소 1개를 return

<!--
### 회원 리포지토리 테스트 케이스 작성

### 회원 서비스 개발

### 회원 서비스 테스트

-->
