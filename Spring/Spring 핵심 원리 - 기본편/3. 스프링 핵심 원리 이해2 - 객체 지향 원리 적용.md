# Spring 핵심 원리 - 스프링 핵심 원리 이해2 - 객체 지향 원리 적용

> 인프런의 "스프링 핵심 원리 - 기본편" 강의를 듣고 정리한 내용입니다.

## 목차

- [새로운 할인 정책 개발](#새로운-할인-정책-개발)
- [새로운 할인 정책 적용과 문제점](#새로운-할인-정책-적용과-문제점)
- [관심사의 분리](#관심사의-분리)
- [AppConfig 리팩터링](#AppConfig-리팩터링)
- [새로운 구조와 할인 정책 적용](#새로운-구조와-할인-정책-적용)
- [전체 흐름 정리](#전체-흐름-정리)
- [좋은 객체 지향 설계의 5가지 원칙의 적용](#좋은-객체-지향-설계의-5가지-원칙의-적용)
- [IoC, DI, 그리고 컨테이너](#IoC,-DI,-그리고-컨테이너)
- [스프링으로 전환하기](#스프링으로-전환하기)

## 새로운 할인 정책 개발

### 할인 정책 확장
- `악덕 기획자` : 서비스 오픈 직전에 할인 정책을 지금처럼 고정 금액 할인이 아니라 좀 더 합리적인 주문 금액당 할인하는 **정률% 할인으로 변경**하고 싶어요.
예를 들어서 기존 정책은 VIP가 10000원을 주문하든 20000원을 주문하든 항상 1000원을 할인했는데,
이번에 새로 나온 정책은 10%로 지정해두면 고객이 10000원 주문시 1000원을 할인해주고, 20000원 주문시에 2000원을 할인해주는 거에요!
- `순진 개발자` : 제가 처음부터 고정 금액 할인은 아니라고 했잖아요.
- `악덕 기획자` : 애자일 소프트웨어 개발 선언 몰라요? “계획을 따르기보다 변화에 대응하기를”
- `순진 개발자` : ... (하지만 난 유연한 설계가 가능하도록 객체지향 설계 원칙을 준수했지 후후)

> `애자일 소프트웨어 개발 선언` : [https://agilemanifesto.org/iso/ko/manifesto.html](https://agilemanifesto.org/iso/ko/manifesto.html)

</br>

이제 정말 **객체지향 설계 원칙**을 잘 준수했는지 확인해보기 위해, **확장된 정책인 정률% 할인**을 추가하자.

</br>

### 정률 할인 정책 클래스 다이어그램
<p align=center>
<img width="587" alt="스크린샷 2024-01-24 13 56 20" src="https://github.com/hamsangjin/TIL/assets/103736614/b99d9fd4-95c0-4c0d-9885-e367ae508d97">
</p>

</br>

### 정률 할인 정책 코드
- main/java/hello/core/discount/RateDiscountPolicy.java
```java
package hello.core.discount;

import hello.core.member.Grade;
import hello.core.member.Member;

public class RateDiscountPolicy implements DiscountPolicy{

    private int discountPercent = 10; //10% 할인

    @Override
    public int discount(Member member, int price) {
        if(member.getGrade() == Grade.VIP) {
            return price * discountPercent /  100;
        } else{
            return 0;
        }
    }
}
```

</br>

### 테스트 작성

> `RateDiscountPolicy.java`에서 `cmd+shift+T` 단축키를 누르면 `Create New Test`라는 게 뜨는데, </br>
> 거기서 `Testing Library`에서는 `JUnit`을 선택하고 `OK`를 누르면 테스트 클래스를 만들어 주니 사용하자.

- test/java/hello/core/discount/RateDiscountPolicyTest.java
```java
package hello.core.discount;

import hello.core.member.Grade;
import hello.core.member.Member;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import static org.assertj.core.api.Assertions.*;

public class RateDiscountPolicyTest {

    RateDiscountPolicy discountPolicy = new RateDiscountPolicy();

    @Test
    @DisplayName("VIP는 10퍼센트 할인이 적용되어야 한다.")
    void vip_o(){
        //given
        Member member = new Member(1L, "memberVIP", Grade.VIP);

        //when
        int discount = discountPolicy.discount(member, 10000);

        // then
        assertThat(discount).isEqualTo(1000);
    }

    @Test
    @DisplayName("VIP가 아니면 할인이 적용되지 않아야 한다.")
    void vip_x(){
        //given
        Member member = new Member(2L, "memberBASIC", Grade.BASIC);

        //when
        int discount = discountPolicy.discount(member, 10000);

        //then
        assertThat(discount).isEqualTo(0);
    }
}
```

- `@DisplayName()` : 테스트 결과 이름 설정해주는 어노테이션
- `static import` : 일반적인 import와는 다르게 메소드나 변수를 패키지, 클래스명없이 접근가능하게 해주고, 코드를 읽을 때, `That ~ is ~`로만 읽어서 한 눈에 의도를 파악할 수 있다.

<p align=center>
<img width="366" alt="스크린샷 2024-01-24 14 14 43" src="https://github.com/hamsangjin/TIL/assets/103736614/0f211d69-d496-4c1a-8d0a-24129e0c0c25">
</p>

> 이제 할인정책을 추가하고 테스트까지 완료했다.

</br>

---

</br>

## 새로운 할인 정책 적용과 문제점

### 할인정책 적용

- 먼저 할인 정책을 변경하려면 클라이언트인 `OrderServiceImpl` 코드를 고쳐야한다.
```java
public class OrderServiceImpl implements OrderService {
 //    private final DiscountPolicy discountPolicy = new FixDiscountPolicy();
     private final DiscountPolicy discountPolicy = new RateDiscountPolicy();
 }
```

</br>

### 문제점 발견

- 역할과 구현 분리했고, 다형성 활용 및 인터페이스와 구현 객체 분리까지 했다.
- 그렇게 OCP, DIP같은 객체지향 설계 원칙을 충실히 준수한 거 같지만 아니다.

</br>

- `DIP` : 주문서비스 클라이언트인 `OrderServiceImpl`는 `DiscountPolicy` 인터페이스에 의존해 **DIP**를 지킨 거 같지만, 구현체인 `FixDiscountPolicy`와 `RateDiscountPolicy`에도 의존하고 있어 지키지 못했다. </br>
- `OCP` : 현재 코드는 기능을 확장해서 변경하면, 클라이언트 코드에도 영향을 주기 때문에 **OCP**도 위반이다.

> 왜 클라이언트 코드를 변경해야해서 OCP를 위반하는지 클래스 다이어그램으로 의존관계를 분석해보자.

</br>

### 의존 관계

- **기대했던 의존관계**
<p align=center>
<img width="589" alt="스크린샷 2024-01-24 15 02 58" src="https://github.com/hamsangjin/TIL/assets/103736614/547deb8e-b199-4e31-be24-971da72ea90c">
</p>

- 이렇게 단순히 `DiscountPolicy` 인터페이스만 의존한다고 생각했다.

</br>

- **실제 의존관계**
<p align=center>
<img width="589" alt="스크린샷 2024-01-24 15 05 15" src="https://github.com/hamsangjin/TIL/assets/103736614/748328a0-fa5e-4a24-94e4-717e38c17016">
</p>

- 하지만 클라이언트인 `OrderServiceImpl`이 `DiscountPolicy` 인터페이스뿐만 아니라 `FixDiscountPolicy`인 구체 클래스도 함께 의존하고 있어 DIP 위반이다.

</br>

- **정책 변경**
<p align=center>
<img width="584" alt="스크린샷 2024-01-24 15 06 38" src="https://github.com/hamsangjin/TIL/assets/103736614/a39ac9d0-5979-48bf-a318-5cd1c05d53be">
</p>

- 그래서 아까처럼 `FixDiscountPolicy`를 `RateDiscountPolicy`로 변경하는 순간 `OrderServiceImpl`의 소스 코드도 함께 변경해야 해서 **OCP 위반**이다.

</br>

### 어떻게 문제를 해결할 수 있을까?

- 클라이언트 코드인 `OrderServiceImpl` 은 `DiscountPolicy`의 인터페이스뿐만 아니라 구체 클래스도 함께 의존한다.
- 그래서 구체 클래스를 변경할 때 클라이언트 코드도 함께 변경해야 한다.
- 아까 [기대했던 의존관계](#의존-관계)처럼 추상(인터페이스)에만 의존하도록 변경해 **DIP 위반**을 해결해보자

</br>

- 인터페이스에만 의존하도록 코드 변경
```java
 public class OrderServiceImpl implements OrderService {
     //private final DiscountPolicy discountPolicy = new RateDiscountPolicy();
     private DiscountPolicy discountPolicy;
}
```

- 이렇게 인터페이스에만 의존하도록 변경했지만, 구현체가 없는데 어떻게 코드를 실행할까?
- 실제로 실행을 해보면 `NPE(Null Pointer Exception)`가 발생한다.

</br>

> 따라서 누군가가 클라이언트인 `OrderServiceImpl`에 `DiscountPolicy`의 구현체를 대신 생성하고 주입해줘야 한다.

</br>

---

</br>

## 관심사의 분리

- **애플리케이션을 하나의 공연**이라고 생각하고, **각각의 인터페이스를 배역**이라 생각했을 때, 실제 배역에 맞는 배우를 선택하는 건 누가할까?
- 그거는 당연히 배우들이 정하는 것이 아니다.
- 하지만 이전 코드는 마치 로미오 역할을 하는 홍길동이 줄리엣 역할을 하는 여자 주인공을 직접 선택하는 것과 같다.
- 그렇다면 홍길동은 공연도 해야하며, 여자 주인공도 직접 선택해야하는 **다양한 책임**을 가지게 된다.

</br>

### 관심사를 분리하자
- 배우는 본인의 역할인 배역을 수행하는 것에만 집중해야하며, 홍길동은 어떤 여자 주인공이 선택되더라도 똑같이 공연을 할 수 있어야 한다.
- 공연을 구성하고, 담당을 섭외하고, 역할에 맞는 배우를 지정하는 책임을 담당하는 별도의 **공연 기획자**를 만들어 책임을 분리해보자.

</br>

### AppConfig 등장
- 애플리케이션의 전체 동작 방식을 구성하기 위해, **구현 객체를 생성**하고, **연결하는 책임**을 가지는 별도의 **설정 클래스**를 만들자.

- main/java/hello/core/AppConfig.java
```java
package hello.core;

import hello.core.discount.FixDiscountPolicy;
import hello.core.member.MemberService;
import hello.core.member.MemberServiceImpl;
import hello.core.member.MemoryMemberRepository;
import hello.core.order.OrderService;
import hello.core.order.OrderServiceImpl;

public class AppConfig {

    public MemberService memberService() {
        return new MemberServiceImpl(new MemoryMemberRepository());
    }

    public OrderService orderService() {
        return new OrderServiceImpl(
                new MemoryMemberRepository(),
                new FixDiscountPolicy());
    }
}
```

- `AppConfig`는 애플리케이션의 실제 동작에 필요한 구현 객체를 생성한다.
  - `MemberServiceImpl`
  - `MemoryMemberRepository`
  - `OrderServiceImpl`
  - `FixDiscountPolicy`
- `AppConfig`는 생성한 객체 인스턴스의 참조를 생성자를 통해서 주입(연결)해준다.

> 현재는 각 클래스에 생성자가 없어 컴파일 오류가 발생하니 바로 생성자를 만들어주자

</br>

- main/java/hello/core/member/MemberServiceImpl.java(생성자 주입)
```java
package hello.core.member;

public class MemberServiceImpl implements MemberService{

    private final MemberRepository memberRepository;

    // 생성자 주입 !!
    public MemberServiceImpl(MemberRepository memberRepository) {
        this.memberRepository = memberRepository;
    }

    @Override
    public void join(Member member) {
        memberRepository.save(member);
    }

    @Override
    public Member findMember(Long memberId) {
        return memberRepository.findById(memberId);
    }
}

```

- 설계 변경으로 `MemberServiceImpl`은 구현체인 `MemoryMemberRepository`를 의존하지 않고, 인터페이스인 `MemberRepository`만 의존한다.
- `MemberServiceImpl` 입장에선 생성자를 통해 어떤 구현 객체가 주입될지 알 수 없고, 어떤 구현 객체를 주입할지는 오직 외부(AppConfig)에서 결정된다.

</br>

- 클래스 다이어그램 그림
<p align=center>
<img width="589" alt="스크린샷 2024-01-24 16 04 09" src="https://github.com/hamsangjin/TIL/assets/103736614/c0152abd-4dc6-4ad2-919c-a5983329dc40">
</p>

- 객체의 생성과 연결은 `AppConfig`가 담당한다.
- **DIP 완성** : `MemberServiceImpl`은 `MemberRepository`인 추상에만 의존하면 되며, 이제 구체 클래스를 몰라도 된다.
- **관심사의 분리** : 객체를 생성하고 연결하는 역할과 실행하는 역할이 명확히 분리되었다.

</br>

- 회원 객체 인스턴스 다이어그램 그림
<p align=center>
<img width="599" alt="스크린샷 2024-01-24 16 09 41" src="https://github.com/hamsangjin/TIL/assets/103736614/7ef6c903-8b5d-4d34-826b-35852f63c67b">
</p>

- `appConfig` 객체는 `MemoryMemberRepository` 객체를 생성하고, 그 참조값을 `memberServiceImpl`을 생성하면서 생성자로 전달한다.
- 클라이언트인 `memberServiceImpl` 입장에서 보면 의존관계를 마치 외부에서 주입해주는 것 같다고 해서 `DI(Dependency Injection)`, 우리말로 `의존관계 주입` 또는 `의존성 주입`이라고 한다.

</br>

- main/java/hello/core/order/OrderServiceImpl.java(생성자 주입)
```java
package hello.core.order;

import hello.core.discount.DiscountPolicy;
import hello.core.discount.FixDiscountPolicy;
import hello.core.discount.RateDiscountPolicy;
import hello.core.member.Member;
import hello.core.member.MemberRepository;
import hello.core.member.MemoryMemberRepository;

public class OrderServiceImpl implements OrderService{

    private final MemberRepository memberRepository;
    private final DiscountPolicy discountPolicy;

    // 생성자 주입 !!
    public OrderServiceImpl(MemberRepository memberRepository, DiscountPolicy discountPolicy) {
        this.memberRepository = memberRepository;
        this.discountPolicy = discountPolicy;
    }

    @Override
    public Order createOrder(Long memberId, String itemName, int itemPrice) {
        Member member = memberRepository.findById(memberId);
        int discountPrice = discountPolicy.discount(member, itemPrice);

        return new Order(memberId, itemName, itemPrice, discountPrice);
    }
}

```

- 설계 변경으로 `OrderServiceImpl`은 구현체인 `FixDiscountPolicy`를 의존하지 않으며, 인터페이스인 `DiscountPolicy`만 의존한다.
- `MemberServiceImpl`처럼 `OrderServiceImpl` 입장에선 생성자를 통해 어떤 구현 객체가 주입될지 알 수 없고, 어떤 구현 객체를 주입할지는 오직 외부(AppConfig)에서 결정된다.

### AppConfig 실행

- main/java/hello/core/MemberApp.java
```java
package hello.core;

import hello.core.member.Grade;
import hello.core.member.Member;
import hello.core.member.MemberService;

public class MemberApp {

    public static void main(String[] args) {
        AppConfig appConfig = new AppConfig();
        MemberService memberService = appConfig.memberService();

        Member member = new Member(1L, "member1", Grade.VIP);
        memberService.join(member);

        Member findMember = memberService.findMember(1L);
        System.out.println("new member = " + member.getName());
        System.out.println("find Member = " + findMember.getName());
    }
}

```

</br>

- main/java/hello/core/OrderApp.java
```java
package hello.core;

import hello.core.member.Grade;
import hello.core.member.Member;
import hello.core.member.MemberService;
import hello.core.member.MemberServiceImpl;
import hello.core.order.Order;
import hello.core.order.OrderService;
import hello.core.order.OrderServiceImpl;

public class OrderApp {
    public static void main(String[] args) {
        AppConfig appConfig = new AppConfig();
        MemberService memberService = appConfig.memberService();
        OrderService orderService = appConfig.orderService();

        Long memberId = 1L;
        Member member = new Member(memberId, "memberA", Grade.VIP);
        memberService.join(member);

        Order order = orderService.createOrder(memberId, "itemA", 10000);
        System.out.println("Order = " + order);
        System.out.println("order.calculatePrice = " + order.calculatePrice());
    }
}
```

</br>

### 테스트

- test/java/hello/core/member/MemberServiceTest.java
```java
public class MemberServiceTest {

    MemberService memberService;

    @BeforeEach
    public void beforeEach() {
        AppConfig appConfig = new AppConfig();
        memberService = appConfig.memberService();
    }
    ...
}
```

</br>

- test/java/hello/core/order/OrderServiceTest.java
```java
public class OrderServiceTest {
    MemberService memberService;
    OrderService orderService;

    @BeforeEach
    public void beforeEach(){
        AppConfig appConfig = new AppConfig();
        memberService = appConfig.memberService();
        orderService = appConfig.orderService();
    }
    ...
}
```

</br>

> `@BeforeEach` : 각 테스트를 실행하기 전에 먼저 호출된다.

</br>

### 정리
- `AppConfig`를 통해서 관심사를 확실하게 분리했다.
- 배역, 배우를 생각했을 때, `AppConfig`는 공연 기획자다.
- 따라서 `AppConfig`는 구체 클래스, 즉 배역에 맞는 담당 배우를 선택하며, 애플리케이션이 어떻게 동작해야 할지 전체 구성을 책임진다.
- 이제 각 배우들은 담당 기능을 실행하는 책임만 지면 되듯이, `OrderServiceImpl`은 기능을 실행하는 책임만 지면 된다.

</br>

---

</br>

## AppConfig 리팩터링

> 현재 `AppConfig`를 보면 **중복**이 있으며, **역할에 따른 구현**이 명확하게 안 보인다.

### AppConfig 리팩터링

- 기대하는 주문 도메인 그림
<p align=center>
<img width="615" alt="스크린샷 2024-01-25 13 15 59" src="https://github.com/hamsangjin/TIL/assets/103736614/71fcaa5e-1065-4d59-91c9-bff7abc12e0d">
</p>

</br>

- 리팩터링 전 코드
```java
package hello.core;

import hello.core.discount.FixDiscountPolicy;
import hello.core.member.MemberService;
import hello.core.member.MemberServiceImpl;
import hello.core.member.MemoryMemberRepository;
import hello.core.order.OrderService;
import hello.core.order.OrderServiceImpl;

public class AppConfig {

    public MemberService memberService() {
    return new MemberServiceImpl(new MemoryMemberRepository());
    }

    public OrderService orderService() {
        return new OrderServiceImpl(
            new MemoryMemberRepository(),
            new FixDiscountPolicy());
    }
}
```

- 이제 중복을 제거하고, 역할에 따른 구현이 보이도록 리팩터링해보자.

</br>

- 리팩터링 후 코드
```java
package hello.core;

import hello.core.discount.DiscountPolicy;
import hello.core.discount.FixDiscountPolicy;
import hello.core.member.MemberRepository;
import hello.core.member.MemberService;
import hello.core.member.MemberServiceImpl;
import hello.core.member.MemoryMemberRepository;
import hello.core.order.OrderService;
import hello.core.order.OrderServiceImpl;

public class AppConfig {
    
    public MemberRepository memberRepository() {
        return new MemoryMemberRepository();
    }

    public DiscountPolicy discountPolicy(){
        return new FixDiscountPolicy();
    }
    
    public MemberService memberService() {
        return new MemberServiceImpl(memberRepository());
    }

    public OrderService orderService() {
        return new OrderServiceImpl(
                memberRepository(),
                discountPolicy());
    }
}
```

- `new MemoryMemberRepository()` 부분이 중복 제거되었으며, 이제 `AppConfig`를 보면 **역할과 구현 클래스**가 한 눈에 들어와, 애플리케이션 전체 구성이 어떻게 되어있는지 빠르게 파악할 수 있게 되었다.

</br>

---

</br>

## 새로운 구조와 할인 정책 적용

